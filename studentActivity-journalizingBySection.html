<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Student Challenge UI</title>
  <style>
  body {
    font-family: Arial, sans-serif;
    padding: 1em;
    background: #f9f9f9;
    max-width: 600px;
    margin: auto;
  }

  #loginPanel, #activityPanel {
    background: white;
    padding: 1em;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    margin-bottom: 1em;
  }

  #questionPanel {
    margin-top: 1em;
    padding: 1em;
    background: #fffbe6;
    border: 2px solid #ffd700;
    border-radius: 8px;
    text-align: center;
  }

  #questionText {
    font-size: 2em;
    font-weight: bold;
    margin: 1em 0;
  }

  #timerDisplay {
    font-size: 1.2em;
    font-weight: bold;
    color: #d00;
    margin-bottom: 0.5em;
  }

  #answerPanel {
    margin-top: 1em;
  }

  #submitBtn {
    display: block;
    margin: 0 auto 1em auto;
    padding: 0.8em 1.5em;
    font-size: 1em;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }

.journal-account {
  font-family: monospace;
  white-space: pre;
}

  #submitBtn:disabled {
    background: #ccc;
    cursor: not-allowed;
  } 

  .effectsGroup {
    margin-top: 0.5em;
  }

  .effectRow {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em;
    margin-left: 1em;
    margin-top: 0.3em;
  }

  .fieldGroup {
    display: flex;
    flex-direction: column;
    flex: 1 1 auto;
    min-width: 120px;
  }

  .fieldGroup label {
    margin-bottom: 0.2em;
    font-size: 0.9em;
  }

  .fieldGroup select,
  .fieldGroup input {
    padding: 0.3em;
    font-size: 0.95em;
  }

  .groupLabel {
    font-weight: bold;
    margin-bottom: 0.2em;
    display: block;
    font-size: 1em;
  }

  @media (min-width: 600px) {
    .effectRow {
      flex-wrap: nowrap;
      gap: 1em;
    }

    .fieldGroup {
      min-width: 150px;
    }
  }
</style>
</head>
<body>

<!-- üîê Login Panel -->
<div id="loginPanel">
  <h2>Student Login</h2>
  <form id="studentLoginForm">
    <input type="text" id="Idnumber" placeholder="Your ID number" required /><br><br>
    <input type="text" id="sectionCode" placeholder="Section code" required /><br><br>
    <input type="password" id="passWord" placeholder="Your password" required /><br><br>
    <button type="submit">Login</button>
  </form>
</div>

<!-- üéØ activity Panel -->
<div id="activityPanel" style="display:none;">
  <button id="submitBtn" >Submit Answer</button>

  <div id="questionPanel">
    <div id="timerDisplay">Remaining Time: -- seconds</div>
    <div id="questionText">Waiting for an active activity...</div>
    <button id="prevBtn">‚¨ÖÔ∏è Prev</button>
    <button id="nextBtn">Next ‚û°Ô∏è</button>
  </div>

	  <!-- üß© Available Accounts Panel -->
  <div id="availableAccountsPanel"></div>

  <div id="answerPanel" style="display: flex; flex-direction: column; gap: 1em;">
    <!-- üìù Constructed Response Panel -->
    <div id="constructedResponsePanel" style="overflow-x: auto;"></div>
    <div id="submissionSummary" style="margin-top: 1rem;"></div>
    <div id="journalPanel" style="margin-top: 1rem;"></div>

  </div>
</div>
</div>

<!-- üîß Script -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
  import {
    getFirestore, doc, getDoc, collection, getDocs, setDoc
  } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAgOsKAZWwExUzupxSNytsfOo9BOppF0ng",
    authDomain: "jlvcpa-quizzes.firebaseapp.com",
    projectId: "jlvcpa-quizzes",
    storageBucket: "jlvcpa-quizzes.appspot.com",
    messagingSenderId: "629158256557",
    appId: "1:629158256557:web:b3d1a424b32e28cd578b24"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  document.addEventListener("DOMContentLoaded", () => {
    
    // üîÄ Shuffle utility
    const shuffleArray = array =>
      array.map(item => ({ item, sortKey: Math.random() }))
           .sort((a, b) => a.sortKey - b.sortKey)
           .map(({ item }) => item);

    // üß≠ DOM elements
    const loginForm = document.getElementById("studentLoginForm");
    const loginStatus = document.createElement("p");
    loginForm.appendChild(loginStatus);

    const questionText = document.getElementById("questionText");
    const activityPanel = document.getElementById("activityPanel");
    const loginPanel = document.getElementById("loginPanel");

    //const answerInput = document.getElementById("answerInput");
    const submitBtn = document.getElementById("submitBtn");

    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    let shuffledQuestions = [];
    let currentStudent = null;
    let selectedQuestionIndex = 0;
    let studentAnswersLog = {}; // key: questionIndex, value: { question, answerKey, studentAnswers }
    
    let title = "";
    let attendanceId = "";
    let countdownInterval = null;
    let journalRowCount = 0;

    submitBtn.addEventListener("click", async () => {
      await submitStudentAnswer();
    });

function displayQuestion(index) {
  selectedQuestionIndex = index;

  // üî¢ Generate question key
  const questionKey = `q${String(index + 1).padStart(2, "0")}`;

  // üìÖ Sort questions chronologically once (if not already sorted)
  if (!shuffledQuestions._sorted) {
    shuffledQuestions.sort((a, b) => new Date(a.Date) - new Date(b.Date));
    shuffledQuestions._sorted = true; // Prevent re-sorting
  }

  // üìù Display question with date prefix
  const q = shuffledQuestions[index];
  questionText.textContent = q?.Date
    ? `(${q.Date}) - ${q.question}`
    : q?.question || "‚ùì";

  // ‚èÆÔ∏è‚è≠Ô∏è Enable/disable navigation buttons
  prevBtn.disabled = index === 0;
  nextBtn.disabled = index === shuffledQuestions.length - 1;

  // üîç Filter and enable rows for current question
  const allRows = document.querySelectorAll("#journalBody tr");
  allRows.forEach(row => {
    const isCurrent = row.dataset.questionKey === questionKey;
    row.querySelectorAll("input").forEach(input => {
      input.disabled = !isCurrent;
    });
  });

  const currentRows = Array.from(allRows).filter(
    row => row.dataset.questionKey === questionKey
  );

  // ‚ûï Add 4 rows if none exist for this question
  const body = document.getElementById("journalBody");
  if (currentRows.length === 0 && body) {
    for (let i = 0; i < 4; i++) {
      const newRow = createJournalRow(questionKey);
      body.appendChild(newRow);
      journalRowCount++;
    }
  }

  // üîÑ Update scroll behavior
  updateJournalScroll();

  // üß† Reattach input listener for Add Row button
  monitorLastRowForInput();
}

function lockJournalEntriesForCurrentQuestion() {
  const questionKey = `q${String(selectedQuestionIndex + 1).padStart(2, "0")}`;
  const allRows = Array.from(document.querySelectorAll("#journalBody tr"));

  const journalEntries = [];

  for (const row of allRows) {
    // ‚úÖ Only consider rows tagged to this question
    if (row.dataset.questionKey !== questionKey || row.dataset.visible !== "true") continue;

    const date = row.querySelector(".journal-date")?.value.trim();
    const account = row.querySelector(".journal-account")?.value.trim();
    const pr = row.querySelector(".journal-pr")?.value.trim();
    const debit = row.querySelector(".journal-debit")?.value.trim();
    const credit = row.querySelector(".journal-credit")?.value.trim();

    const isEmpty = !date && !account && !pr && !debit && !credit;
    if (isEmpty) continue; // ‚úÖ Skip blank rows

    journalEntries.push({ date, account, pr, debit, credit });

    // üîí Lock this row
    row.querySelectorAll("input").forEach(input => input.disabled = true);
    row.dataset.visible = "false"; // ‚úÖ Mark as locked
  }

  // ‚úÖ Save only if there's something to save
  if (journalEntries.length > 0) {
    studentAnswersLog[questionKey] = {
      question: shuffledQuestions[selectedQuestionIndex],
      journalEntries
    };
  }
}

function restoreJournalEntriesForQuestion(index) {
  const questionKey = `q${String(index + 1).padStart(2, "0")}`;
  const saved = studentAnswersLog[questionKey];
  const panel = document.getElementById("constructedResponsePanel");
  if (!panel) return;

  renderJournalEntryForm(saved?.question?.question || "‚ùì");

  const body = document.getElementById("journalBody");
  journalRowCount = 0;

  if (saved?.journalEntries) {
    saved.journalEntries.forEach(entry => {
      const row = createJournalRow();
      row.querySelector(".journal-date").value = entry.date;
      row.querySelector(".journal-account").value = entry.account;
      row.querySelector(".journal-pr").value = entry.pr;
      row.querySelector(".journal-debit").value = entry.debit;
      row.querySelector(".journal-credit").value = entry.credit;

      // Reactivate inputs
      row.querySelectorAll("input").forEach(input => input.disabled = false);

      body.appendChild(row);
      journalRowCount++;
    });
  }
}

nextBtn.addEventListener("click", () => {
  if (!validateJournalStructure()) return;

  // üîí Lock current journal entries
  lockJournalEntriesForCurrentQuestion();
  
  const body = document.getElementById("journalBody");
  if (!body) return;

  if (selectedQuestionIndex >= shuffledQuestions.length - 1) return;

  const selectedQuestion = shuffledQuestions[selectedQuestionIndex];
    selectedQuestionIndex++;
    displayQuestion(selectedQuestionIndex);
    //updateSubmitButtonState();    
    return;

  // ‚û°Ô∏è Move to next question
  selectedQuestionIndex++;
  displayQuestion(selectedQuestionIndex);
   //updateSubmitButtonState();
});

prevBtn.addEventListener("click", () => {
  if (!validateJournalStructure()) return;

  // üîí Lock current journal entries
  lockJournalEntriesForCurrentQuestion();

  if (selectedQuestionIndex <= 0) return;

  const selectedQuestion = shuffledQuestions[selectedQuestionIndex];
  
    selectedQuestionIndex--;
    displayQuestion(selectedQuestionIndex);
    //updateSubmitButtonState();
    return;
  
  // ‚¨ÖÔ∏è Move to previous question
  selectedQuestionIndex--;
  displayQuestion(selectedQuestionIndex);
  //updateSubmitButtonState();
});

function logAnswerForQuestion(
  index,
  { score = null, questionScore = null, markedType = null, markedEffects = [] , selectedAnswer },
  status = "Not scored yet",
  targetObject = studentAnswersLog
) {
  const question = shuffledQuestions[index];
  const correctAnswer = question.correctAnswer;

  // ‚úÖ Use lowercase key for consistency with restoration logic
  const questionKey = `q${String(index + 1).padStart(2, "0")}`;

  // üß† Always log raw input for restoration
  targetObject[questionKey] = {
    "01_question": question.question,
    "02_scoreThisQuestion": (score !== null && questionScore !== null)
      ? `${score} out of ${questionScore}`
      : status,
    "03_questionAnswerKey": {
      "a_answerKeyType": correctAnswer?.type || null,
      "b_answerKeyEffects": correctAnswer?.effects || null
    },
    "04_studentAnswers": {
      "a_studentAnswerType": markedType || selectedAnswer?.type || null,
      "b_studentAnswerEffects": markedEffects || [],
      "c_rawStudentInput": selectedAnswer || {}
    }
  };
}

    async function validateStudent(id, password, sectionCode) {
      const attendanceRef = doc(db, "attendance", sectionCode);
      const attendanceSnap = await getDoc(attendanceRef);
      if (!attendanceSnap.exists()) throw new Error("Attendance record not found.");

      const student = attendanceSnap.data().students.find(s =>
        s.Idnumber === id && s.passWord === password
      );

      if (!student) throw new Error("Invalid credentials.");
      if (student.status === "A") throw new Error("Marked absent.");

      attendanceId = sectionCode;

  // ‚úÖ Check if student already submitted answers
  const activity = await findActiveActivity(sectionCode); // sets global studentAnswersLog
  const title = activity.title || "Untitled";

  const collectionId = `results_${title}_${sectionCode}`;
  const documentId = `${student.CN}-${student.Idnumber}-${student.LastName}-${student.firstName}`;
  const resultRef = doc(db, collectionId, documentId);
  const resultSnap = await getDoc(resultRef);

  if (resultSnap.exists()) {
    throw new Error("Already submitted answers for this activity.");
  }

      return student;
    }

async function findActiveActivity(sectionCode) {
  const now = Date.now();
  const activitiesSnap = await getDocs(collection(db, "activities"));

  const matched = activitiesSnap.docs.find(doc => {
    const id = doc.id;
    const data = doc.data();

    const isMatchingSection = id.endsWith(`_${sectionCode}`);
    const endTimeMillis = new Date(data.endTime).getTime();
    const isStillActive = endTimeMillis > now;

    return isMatchingSection && isStillActive;
  });

  if (!matched) {
    throw new Error("No active activity found.");
  }

  const activityData = matched.data();

  // ‚úÖ Log activity metadata into studentAnswersLog
  Object.assign(studentAnswersLog, {
    title: activityData.title || "Untitled",
    type: activityData.type || "unspecified",
    topics: activityData.topics || [],
    num: activityData.numOfQuestions || 0,
    instructions: activityData.instructions || "No instructions provided.",
    rubricHTML: activityData.rubricHTML || "<p>No rubric available.</p>",
    duration: activityData.duration || "unspecified",
    endTime: activityData.endTime || new Date().toISOString()
  });

  console.log("‚úÖ Active activity found and logged:", activityData);
  return activityData;
}




    function startCountdown(durationMinutes) {
      const durationMillis = durationMinutes * 60 * 1000;
      const endTime = Date.now() + durationMillis;

      function updateTimer() {
  const remainingMillis = endTime - Date.now();
  const remainingSeconds = Math.max(0, Math.floor(remainingMillis / 1000));

  const minutes = Math.floor(remainingSeconds / 60);
  const seconds = remainingSeconds % 60;

  const paddedMinutes = String(minutes).padStart(2, '0');
  const paddedSeconds = String(seconds).padStart(2, '0');

  document.getElementById("timerDisplay").textContent =
    `Remaining Time: ${paddedMinutes}:${paddedSeconds}`;

  if (remainingSeconds <= 0) {
    clearInterval(countdownInterval);
    console.log("‚è∞ Time's up!");
    submitStudentAnswer(); // or disable inputs, show message, etc.
  }
}

      updateTimer(); // run immediately
      countdownInterval = setInterval(updateTimer, 1000);

      // ‚è≥ Schedule auto-submit
      setupAutoSubmit(endTime);
    }

function startActivity(questions) {
  if (!questions || questions.length === 0) {
    questionText.textContent = "‚ùå No questions found in this activity.";
    return;
  }

  const enrichedQuestions = questions.map((q, i) => {
    const answersArray = Array.isArray(q.answer) ? q.answer : [q.answer];
    const correctAnswer = answersArray.find(a => a?.type && Array.isArray(a.effects));
    return {
      ...q,
      correctAnswer: correctAnswer || null
    };
  });

  shuffledQuestions = shuffleArray(enrichedQuestions);
  selectedQuestionIndex = 0;

  // ‚úÖ Render the journal form first
  renderJournalEntryForm("Journalizing Activity");

  // ‚úÖ Then display the first question
  displayQuestion(selectedQuestionIndex);

  loginPanel.style.display = "none";
  activityPanel.style.display = "block";
  submitBtn.disabled = false;
  startCountdown(studentAnswersLog.duration);
}

function extractAndRenderMetadata(questions) {
  const accountsSet = new Set();

  questions.forEach(q => {
    const answersArray = Array.isArray(q.answer) ? q.answer : [q.answer];

    answersArray.forEach(a => {
      if (a?.account) accountsSet.add(a.account);

      if (Array.isArray(a.effects)) {
        a.effects.forEach(effect => {
          if (effect?.account) accountsSet.add(effect.account);
        });
      }
    });
  });

  const sortedAccounts = [...accountsSet].sort();
  window.availableAccounts = sortedAccounts;

  extractAndRenderAvailableAccounts(sortedAccounts);
}

function extractAndRenderAvailableAccounts(accounts) {
  const panel = document.getElementById("availableAccountsPanel");
  if (!panel) {
    console.warn("‚ö†Ô∏è 'availableAccountsPanel' not found.");
    return;
  }

  panel.innerHTML = ""; // Clear previous content

  if (accounts.length === 0) {
    panel.textContent = "‚ö†Ô∏è No accounts found.";
    return;
  }

  const columnCount = 3;
  const columns = Array.from({ length: columnCount }, () => document.createElement("ul"));

  accounts.forEach((account, index) => {
    const columnIndex = index % columnCount;
    const item = document.createElement("li");
    item.textContent = account;
    columns[columnIndex].appendChild(item);
  });

  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.gap = "2rem";

  columns.forEach(col => {
    col.style.flex = "1";
    container.appendChild(col);
  });

  panel.appendChild(container);
}

    loginForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const id = document.getElementById("Idnumber").value.trim();
      const sectionCode = document.getElementById("sectionCode").value.trim();
      const password = document.getElementById("passWord").value.trim();

      loginStatus.textContent = "üîç Validating...";
      try {
        currentStudent = await validateStudent(id, password, sectionCode);
        loginStatus.textContent = "‚úÖ Login successful. Checking for activity...";
        const activity = await findActiveActivity(sectionCode);
        if (!activity) {
          loginStatus.textContent = "‚ö†Ô∏è No active activity found for this section.";
          return;
        }

        const questions = activity.questions || [];
        console.log("üì¶ Activity found:", activity);
        console.log("üìã Questions in activity:", activity.questions);
        try {
          console.log("üöÄ Starting activity...");
          startActivity(questions);
          console.log("‚úÖ Activity started.");
          console.log("üß† Extracting metadata...");
          extractAndRenderMetadata(questions);
          console.log("‚úÖ Metadata rendered.");

        } catch (err) {
          console.error("üî• Error during activity rendering:", err.message);
          loginStatus.textContent = `üö´ Failed to render activity: ${err.message}`;
        }

      } catch (err) {
        console.error("üî• Error:", err.message);
        loginStatus.textContent = `üö´ ${err.message}`;
      }
    });

function renderJournalEntryForm(headerText) {
  const panel = document.getElementById("constructedResponsePanel");
  if (!panel) {
    console.warn("‚ö†Ô∏è constructedResponsePanel not found.");
    return;
  }

  panel.innerHTML = `
    <h3>${headerText}</h3>
    <div style="overflow-x: auto;">
      <table style="width: max-content; border-collapse: collapse;">
        <thead>
          <tr>
<th style="width: 7ch; font-family: monospace; font-size: 14px;">Date</th>
<th style="width: 40ch; font-family: monospace; font-size: 14px;">Account Titles and Explanation</th>
<th style="width: 3ch; font-family: monospace; font-size: 14px;">PR</th>
<th style="width: 10ch; font-family: monospace; font-size: 14px; text-align: center;">Debit</th>
<th style="width: 10ch; font-family: monospace; font-size: 14px; text-align: center;">Credit</th>

          </tr>
        </thead>
      </table>
    <div style="max-height: 300px; overflow-y: auto;">
      <table id="journalTable" style="width: max-content; border-collapse: collapse;">
        <tbody id="journalBody"></tbody>
      </table>
    </div>
  </div>

    <button id="addJournalRowBtn" style="margin-top: 0.5rem;" disabled>‚ûï Add Row</button>
    <div id="journalFeedback" style="color: red; margin-top: 0.5rem;"></div>
  `;

  journalRowCount = 0;

  setTimeout(() => {
    const body = document.getElementById("journalBody");
    const addRowBtn = document.getElementById("addJournalRowBtn");
    if (!body || !addRowBtn) {
      console.warn("‚ö†Ô∏è journalBody or addJournalRowBtn not found.");
      return;
    }

    // ‚ûï Add one row when button is clicked
    addRowBtn.addEventListener("click", () => {
      if (journalRowCount >= 10) return;

      const questionKey = `q${String(selectedQuestionIndex + 1).padStart(2, "0")}`;
      const newRow = createJournalRow(questionKey);
      body.appendChild(newRow);
      journalRowCount++;

      addRowBtn.disabled = true;
      monitorLastRowForInput();
    });
  }, 0);
}

function createJournalRow(questionKey = null) {
  const row = document.createElement("tr");

  // ‚úÖ Tag immediately if questionKey is provided
  if (questionKey) {
    row.dataset.questionKey = questionKey;
    row.dataset.visible = "true";
  }

  row.innerHTML = `
    <td><input type="text" class="journal-date" maxlength="7" style="text-align: right; width: 7ch;" /></td>
    <td><input type="text" class="journal-account" style="width: 39.5ch; font-family: monospace; white-space: pre;" /></td>
    <td><input type="text" class="journal-pr" maxlength="3" style="text-align: center; width: 3ch;" /></td>
    <td><input type="text" class="journal-debit" maxlength="12" style="text-align: right; width: 10ch;" /></td>
    <td><input type="text" class="journal-credit" maxlength="12" style="text-align: right; width: 10ch;" /></td>
  `;

  // üß† Still keep the input listener for fallback tagging
  const inputs = row.querySelectorAll("input");
  inputs.forEach(input => {
    input.addEventListener("input", () => {
      if (!row.dataset.questionKey && questionKey) {
        row.dataset.questionKey = questionKey;
        row.dataset.visible = "true";
      }
    });
  });

  setTimeout(updateJournalScroll, 0);
  return row;
}


function monitorLastRowForInput() {
  const body = document.getElementById("journalBody");
  const addRowBtn = document.getElementById("addJournalRowBtn");
  if (!body || !addRowBtn) return;

  const rows = Array.from(body.querySelectorAll("tr"));
  const lastRow = rows[rows.length - 1];
  if (!lastRow) return;

  const inputs = lastRow.querySelectorAll("input");

  const checkInput = () => {
    const hasInput = Array.from(inputs).some(inp => inp.value.trim());
    addRowBtn.disabled = !hasInput;
  };

  inputs.forEach(input => {
    input.addEventListener("input", checkInput);
    input.addEventListener("change", checkInput);
    input.addEventListener("blur", checkInput); // ‚úÖ catches outside click
    input.addEventListener("paste", checkInput); // ‚úÖ catches paste
  });

  // Initial check in case input already exists
  checkInput();
}

/*function validateJournalStructure() {
  const rows = document.querySelectorAll("#journalBody tr");
  const feedback = document.getElementById("journalFeedback");
  feedback.textContent = "";

  let monthEntered = null;
  let dateEntered = false;
  let hasDebit = false;
  let hasCredit = false;
  let hasExplanation = false;

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const dateRaw = row.querySelector(".journal-date").value.trim();
    const accountRaw = row.querySelector(".journal-account").value;
    const debitValue = row.querySelector(".journal-debit").value.trim();
    const creditValue = row.querySelector(".journal-credit").value.trim();

    const accountTrimmed = accountRaw.trim();

      // ‚úÖ Add this block right here
  const cleanDebit = debitValue.replace(/[^\d.-]/g, "").trim();
  if (cleanDebit && !isNaN(parseFloat(cleanDebit))) {
    hasDebit = true;
  }

  const cleanCredit = creditValue.replace(/[^\d.-]/g, "").trim();
  if (cleanCredit && !isNaN(parseFloat(cleanCredit))) {
    hasCredit = true;
  }

    // üóìÔ∏è Row 1: Year only
    if (i === 0) {
      if (!/^\d{4}$/.test(dateRaw)) {
        feedback.textContent = `‚ö†Ô∏è Row 1: Enter a valid year in YYYY format.`;
        return false;
      }

      if (accountTrimmed || debitValue || creditValue) {
        feedback.textContent = `‚ö†Ô∏è Row 1: Year row should not contain account or amount entries.`;
        return false;
      }
      continue;
    }

    // üóìÔ∏è Row 2: Month and day
    if (i === 1) {
      if (!/^[A-Za-z]{3} \d{1,2}$/.test(dateRaw)) {
        feedback.textContent = `‚ö†Ô∏è Row 2: Enter date as "Mmm d" or "Mmm dd".`;
        return false;
      }
      monthEntered = dateRaw.split(" ")[0];
      dateEntered = true;
      continue;
    }

    // üóìÔ∏è Subsequent rows
    if (dateRaw) {
      if (/^[A-Za-z]{3} \d{1,2}$/.test(dateRaw)) {
        const currentMonth = dateRaw.split(" ")[0];
        if (currentMonth === monthEntered) {
          feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: New month must differ from initial month "${monthEntered}".`;
          return false;
        }
        monthEntered = currentMonth;
      } else if (!/^\d{1,2}$/.test(dateRaw)) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Enter day as "d" or "dd" only.`;
        return false;
      }
      dateEntered = true;
    } else if (!dateEntered) {
      feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: First transaction row must include a date.`;
      return false;
    }

    // üßæ Explanation row
    const isExplanation = accountTrimmed && !debitValue && !creditValue;
    if (isExplanation) {
      hasExplanation = true;

      if (!/^ {8}\S/.test(accountRaw)) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Explanation must be indented by 8 spaces.`;
        return false;
      }

      const nextRow = rows[i + 1];
      if (!nextRow) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Explanation must be followed by one blank row.`;
      }

      const nextInputs = [
        ".journal-date",
        ".journal-account",
        ".journal-pr",
        ".journal-debit",
        ".journal-credit"
      ].map(selector => nextRow.querySelector(selector)?.value.trim());

      const isBlankRow = nextInputs.every(val => !val);
      if (!isBlankRow) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 2}: You must leave one blank row after the explanation in Row ${i + 1}.`;

        return false;
      }
    }

    // üí≥ Debit and credit checks
    if (debitValue && !isNaN(parseFloat(debitValue))) {
      hasDebit = true;
    }
    if (creditValue && !isNaN(parseFloat(creditValue))) {
      hasCredit = true;
    }
  }

  // ‚úÖ Final check for required components
  const missing = [];
  if (!hasDebit) missing.push("a debit entry");
  if (!hasCredit) missing.push("a credit entry");
  if (!hasExplanation) missing.push("an explanation row");

  if (missing.length > 0) {
    feedback.textContent = `‚ö†Ô∏è Your journal must include at least ${missing.join(", ")}.`;
    return false;
  }

  return true;
} */

/*function validateJournalStructure() {
  const rows = document.querySelectorAll("#journalBody tr");
  const feedback = document.getElementById("journalFeedback");
  feedback.textContent = "";

  const questionKey = `q${String(selectedQuestionIndex + 1).padStart(2, "0")}`;
const currentRows = Array.from(document.querySelectorAll("#journalBody tr"))
  .filter(row => row.dataset.questionKey === questionKey);

let previousYear = null;
let firstRowHasYear = false;
  let monthEntered = null;
  let dateEntered = false;
  let hasDebit = false;
  let hasCredit = false;
  let hasExplanation = false;
  let initialYear = null;


  for (let i = 0; i < currentRows.length; i++) {
    const row = currentRows[i];
    const dateRaw = row.querySelector(".journal-date").value.trim();
    const accountRaw = row.querySelector(".journal-account").value;
    const debitValue = row.querySelector(".journal-debit").value.trim();
    const creditValue = row.querySelector(".journal-credit").value.trim();
    const hasAccountOrAmount = accountRaw || debitValue || creditValue;


const accountTrimmed = accountRaw.trim();

// üîí Validate account name against allowed list
if (accountTrimmed && !window.availableAccounts.includes(accountTrimmed)) {
  feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: "${accountTrimmed}" is not in the list of allowed accounts. Please use only the accounts provided.`;
  return false;
}

// üí∞ Validate amount format BEFORE cleaning
const amountFormatRegex = /^\d{1,3}(,\d{3})*(\.\d{2})$/;

if (debitValue && !amountFormatRegex.test(debitValue)) {
  feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Debit amount must include commas and two decimal places (e.g., "12,500.00").`;
  return false;
}
if (creditValue && !amountFormatRegex.test(creditValue)) {
  feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Credit amount must include commas and two decimal places (e.g., "12,500.00").`;
  return false;
}

// üßº Clean and check numeric values ‚Äî MUST come before any return
const cleanDebit = debitValue.replace(/[^\d.-]/g, "").trim();
if (cleanDebit && !isNaN(parseFloat(cleanDebit))) {
  hasDebit = true;
}

const cleanCredit = creditValue.replace(/[^\d.-]/g, "").trim();
if (cleanCredit && !isNaN(parseFloat(cleanCredit))) {
  hasCredit = true;
}
console.log(`Row ${i + 1} debit raw: "${debitValue}", cleaned: "${cleanDebit}"`);

// üîí Validate account name AFTER cleaning
if (accountTrimmed && (debitValue || creditValue)) {
  if (!window.availableAccounts.includes(accountTrimmed)) {
    feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: "${accountTrimmed}" is not in the list of allowed accounts. Please use only the accounts provided.`;
    return false;
  }
}


    // üóìÔ∏è Row 1: Year only
if (i === 0) {
  if (/^\d{4}$/.test(dateRaw)) {
    if (hasAccountOrAmount) {
      feedback.textContent = `‚ö†Ô∏è Row 1: Year row must not contain account or amount entries.`;
      return false;
    }

    const year = parseInt(dateRaw, 10);
    if (previousYear !== null && year !== previousYear + 1) {
      feedback.textContent = `‚ö†Ô∏è Row 1: Year must be ${previousYear + 1} if entered.`;
      return false;
    }

    previousYear = year;
    firstRowHasYear = true;
    continue;
  }

  if (/^[A-Za-z]{3} \d{1,2}$/.test(dateRaw)) {
    // Month and day format ‚Äî allowed if new month is needed
    firstRowHasYear = false;
    monthEntered = dateRaw.split(" ")[0];
    dateEntered = true;
    continue;
  }

  if (/^\d{1,2}$/.test(dateRaw)) {
    // Day-only format ‚Äî allowed for continuing within same month
    dateEntered = true;
    continue;
  }

  feedback.textContent = `‚ö†Ô∏è Row 1: Enter a valid year (YYYY), a full date ("Mmm d"), or just a day ("d" or "dd").`;
  return false;
}


  // üü® Row 2 onward
  if (i > 0) {
    if (/^\d{4}$/.test(dateRaw)) {
      feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Year input is only allowed in Row 1.`;
      return false;
    }

if (/^[A-Za-z]{3} \d{1,2}$/.test(dateRaw)) {
  if (firstRowHasYear) {
    dateEntered = true; // ‚úÖ Mark that a valid date was entered
    continue;
  } else {
    feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Date input is only allowed in Row 1.`;
    return false;
  }
}

    if (dateRaw) {
      feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Invalid date format. Only Row 1 may contain a date.`;
      return false;
    }
  }

// üí∞ Credit row indentation check
const isCreditEntry = cleanCredit && !isNaN(parseFloat(cleanCredit));
if (isCreditEntry) {
  if (!/^ {5}\S/.test(accountRaw)) {
    feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Credited account must be indented by 5 spaces.`;
    return false;
  }
}

    // üßæ Explanation row
    const isExplanation = accountTrimmed && !debitValue && !creditValue;
    if (isExplanation) {
      hasExplanation = true;

      if (!/^ {8}\S/.test(accountRaw)) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Explanation must be indented by 8 spaces.`;
        return false;
      }

      const nextRow = currentRows[i + 1];
      if (!nextRow) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Explanation must be followed by one blank row.`;
        const addRowBtn = document.getElementById("addJournalRowBtn");
        if (addRowBtn) addRowBtn.disabled = false;
        return false;
      }

      const nextInputs = [
        ".journal-date",
        ".journal-account",
        ".journal-pr",
        ".journal-debit",
        ".journal-credit"
      ].map(selector => nextRow.querySelector(selector)?.value.trim());

      const isBlankRow = nextInputs.every(val => !val);
      if (!isBlankRow) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 2}: You must leave one blank row after the explanation in Row ${i + 1}.`;
        return false;
      }
// ‚úÖ Skip the blank row from further validation
i++; // advance the loop index to skip nextRow
continue;

    }


  }

  // ‚úÖ Final check for required components
  const missing = [];
  if (!dateEntered) missing.push("a date entry");
  if (!hasDebit) missing.push("a debit entry");
  if (!hasCredit) missing.push("a credit entry");
  if (!hasExplanation) missing.push("an explanation row");

  if (missing.length > 0) {
    feedback.textContent = `‚ö†Ô∏è You must complete ${missing.join(", ")} before navigating away from this question.`;
    return false;
  }

  return true;
}*/

function validateJournalStructure() {
  const rows = document.querySelectorAll("#journalBody tr");
  const feedback = document.getElementById("journalFeedback");
  feedback.textContent = "";

  const questionKey = `q${String(selectedQuestionIndex + 1).padStart(2, "0")}`;
  const currentRows = Array.from(document.querySelectorAll("#journalBody tr"))
    .filter(row => row.dataset.questionKey === questionKey);

  let previousYear = null;
  let firstRowHasYear = false;
  let monthEntered = null;
  let dateEntered = false;
  let hasDebit = false;
  let hasCredit = false;
  let hasExplanation = false;

  for (let i = 0; i < currentRows.length; i++) {
    const row = currentRows[i];
    const dateRaw = row.querySelector(".journal-date").value.trim();
    const accountRaw = row.querySelector(".journal-account").value;
    const debitValue = row.querySelector(".journal-debit").value.trim();
    const creditValue = row.querySelector(".journal-credit").value.trim();
    const accountTrimmed = accountRaw.trim();
    const hasAccountOrAmount = accountRaw || debitValue || creditValue;

    // üßº Clean and check numeric values
    const cleanDebit = debitValue.replace(/[^\d.-]/g, "").trim();
    if (cleanDebit && !isNaN(parseFloat(cleanDebit))) {
      hasDebit = true;
    }

    const cleanCredit = creditValue.replace(/[^\d.-]/g, "").trim();
    if (cleanCredit && !isNaN(parseFloat(cleanCredit))) {
      hasCredit = true;
    }

console.log(`Row ${i + 1} debit raw: "${debitValue}", cleaned: "${cleanDebit}"`);

    // üóìÔ∏è Row 1: Year only
    if (i === 0) {
      if (/^\d{4}$/.test(dateRaw)) {
        if (hasAccountOrAmount) {
          feedback.textContent = `‚ö†Ô∏è Row 1: Year row must not contain account or amount entries.`;
          return false;
        }
        const year = parseInt(dateRaw, 10);
        if (previousYear !== null && year !== previousYear + 1) {
          feedback.textContent = `‚ö†Ô∏è Row 1: Year must be ${previousYear + 1} if entered.`;
          return false;
        }
        previousYear = year;
        firstRowHasYear = true;
        continue;
      }

      if (/^[A-Za-z]{3} \d{1,2}$/.test(dateRaw)) {
        firstRowHasYear = false;
        monthEntered = dateRaw.split(" ")[0];
        dateEntered = true;
        continue;
      }

      if (/^\d{1,2}$/.test(dateRaw)) {
        dateEntered = true;
        continue;
      }

      feedback.textContent = `‚ö†Ô∏è Row 1: Enter a valid year (YYYY), a full date ("Mmm d"), or just a day ("d" or "dd").`;
      return false;
    }

    // üü® Row 2 onward
    if (i > 0) {
      if (/^\d{4}$/.test(dateRaw)) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Year input is only allowed in Row 1.`;
        return false;
      }

      if (/^[A-Za-z]{3} \d{1,2}$/.test(dateRaw)) {
        if (firstRowHasYear) {
          dateEntered = true;
          continue;
        } else {
          feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Date input is only allowed in Row 1.`;
          return false;
        }
      }

      if (dateRaw) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Invalid date format. Only Row 1 may contain a date.`;
        return false;
      }
    }

    // üí∞ Validate amount format BEFORE cleaning
    const amountFormatRegex = /^\d{1,3}(,\d{3})*(\.\d{2})$/;
    if (debitValue && !amountFormatRegex.test(debitValue)) {
      feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Debit amount must include commas and two decimal places (e.g., "12,500.00").`;
      return false;
    }
    if (creditValue && !amountFormatRegex.test(creditValue)) {
      feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Credit amount must include commas and two decimal places (e.g., "12,500.00").`;
      return false;
    }

    // üí∞ Credit row indentation check
    const isCreditEntry = cleanCredit && !isNaN(parseFloat(cleanCredit));
    if (isCreditEntry && !/^ {5}\S/.test(accountRaw)) {
      feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Credited account must be indented by 5 spaces.`;
      return false;
    }

    // üßæ Explanation logic with localized debit/credit check
    const isOnlyAccountEntry = accountTrimmed && !debitValue && !creditValue;
    if (isOnlyAccountEntry) {
      let priorDebitExists = false;
      let priorCreditExists = false;

      for (let j = 0; j < i; j++) {
        const prevRow = currentRows[j];
        const prevDebit = prevRow.querySelector(".journal-debit").value.trim();
        const prevCredit = prevRow.querySelector(".journal-credit").value.trim();

        const cleanPrevDebit = prevDebit.replace(/[^\d.-]/g, "").trim();
        const cleanPrevCredit = prevCredit.replace(/[^\d.-]/g, "").trim();

        if (cleanPrevDebit && !isNaN(parseFloat(cleanPrevDebit))) {
          priorDebitExists = true;
        }
        if (cleanPrevCredit && !isNaN(parseFloat(cleanPrevCredit))) {
          priorCreditExists = true;
        }

        if (priorDebitExists && priorCreditExists) break;
      }

      if (!priorDebitExists || !priorCreditExists) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Explanation cannot appear before both debit and credit entries are completed in earlier rows.`;
        return false;
      }

      // ‚úÖ Explanation indentation check
      if (!/^ {8}\S/.test(accountRaw)) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Explanation must be indented by 8 spaces.`;
        return false;
      }

      // ‚úÖ Blank row after explanation
      const nextRow = currentRows[i + 1];
      if (!nextRow) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: Explanation must be followed by one blank row.`;
        const addRowBtn = document.getElementById("addJournalRowBtn");
        if (addRowBtn) addRowBtn.disabled = false;
        return false;
      }

      const nextInputs = [
        ".journal-date",
        ".journal-account",
        ".journal-pr",
        ".journal-debit",
        ".journal-credit"
      ].map(selector => nextRow.querySelector(selector)?.value.trim());

      const isBlankRow = nextInputs.every(val => !val);
      if (!isBlankRow) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 2}: You must leave one blank row after the explanation in Row ${i + 1}.`;
        return false;
      }

      hasExplanation = true;
      i++; // Skip blank row
      continue;
    }

    // üîí Validate account name against allowed list (non-explanation rows only)
    if (accountTrimmed && (debitValue || creditValue)) {
      if (!window.availableAccounts.includes(accountTrimmed)) {
        feedback.textContent = `‚ö†Ô∏è Row ${i + 1}: "${accountTrimmed}" is not in the list of allowed accounts. Please use only the accounts provided.`;
        return false;
      }
    }

    console.log(`Row ${i + 1} debit raw: "${debitValue}", cleaned: "${cleanDebit}"`);
  }

  // ‚úÖ Final check for required components
  const missing = [];
  if (!dateEntered) missing.push("a date entry");
  if (!hasDebit) missing.push("a debit entry");
  if (!hasCredit) missing.push("a credit entry");
  if (!hasExplanation) missing.push("an explanation row");

  if (missing.length > 0) {
    feedback.textContent = `‚ö†Ô∏è You must complete ${missing.join(", ")} before navigating away from this question.`;
    return false;
  }

  return true;
}

function updateJournalScroll() {
  const body = document.getElementById("journalBody");
  if (!body) return;

  const rows = body.querySelectorAll("tr");
  if (rows.length > 10) {
    body.style.maxHeight = "300px"; // adjust as needed
    body.style.overflowY = "auto";
  } else {
    body.style.maxHeight = "none";
    body.style.overflowY = "hidden";
  }
}

    

function formatAmount(value) {
  // Remove currency symbols and other non-numeric characters
  const cleaned = value.replace(/[^\d.,-]/g, "");
  const num = parseFloat(cleaned.replace(/,/g, ""));
  if (isNaN(num)) return "0.00";
  return num.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
}



    function assembleStudentAnswer() {
      const type = document.getElementById("typeSelect").value;
      const rows = document.querySelectorAll(".effectRow");

      const effects = Array.from(rows).map(row => ({
        element: row.querySelector(".elementSelect").value,
        account: row.querySelector(".accountSelect").value,
        isDebitCredit: row.querySelector(".isDebitCreditSelect").value,
        amount: formatAmount(row.querySelector(".amountInput").value)
      }));

      return { type, effects };
    }



function calculateScoreForQuestion(question) {
  // üõ°Ô∏è Defensive guard for malformed question or missing answer
  if (!question || !question.answer) {
    console.warn("‚ö†Ô∏è Invalid or missing 'answer' field in question:", question);
    return { score: 0, totalPossibleCorrect: 0 };
  }

  const correctAnswers = Array.isArray(question.answer) ? question.answer : [question.answer];
  const studentType = document.getElementById("typeSelect")?.value || "";
  const rows = document.querySelectorAll(".effectRow");

  let score = 0;
  let totalPossibleCorrect = 1; // type match is one point

  // ‚úÖ Type match scoring
  if (correctAnswers.some(ans => ans?.type === studentType)) {
    score += 1;
  }

  // üß† Group correct answers by isDebitCredit
  const correctGroups = {
    Debit: correctAnswers.filter(ans => ans?.isDebitCredit === "Debit"),
    Credit: correctAnswers.filter(ans => ans?.isDebitCredit === "Credit")
  };

  // üß† Group student rows by isDebitCredit
  const studentGroups = {
    Debit: [],
    Credit: []
  };

  Array.from(rows).forEach(row => {
    const element = row.querySelector(".elementSelect")?.value || "";
    const account = row.querySelector(".accountSelect")?.value || "";
    const isDebitCredit = row.querySelector(".isDebitCreditSelect")?.value || "";
    const amount = row.querySelector(".amountInput")?.value || "";

    if (isDebitCredit === "Debit" || isDebitCredit === "Credit") {
      studentGroups[isDebitCredit].push({ element, account, isDebitCredit, amount });
    }
  });

  // üßÆ Match logic per group
  ["Debit", "Credit"].forEach(type => {
    const studentRows = studentGroups[type];
    const correctRows = correctGroups[type];
    const usedCorrectIndexes = new Set();

    const scoredRows = studentRows.map((student, sIndex) => {
      const scores = correctRows.map((correct, cIndex) => ({
        score: scoreMatch(student, correct),
        correctIndex: cIndex
      }));
      const best = scores.sort((a, b) => b.score - a.score)[0];
      return {
        score: best?.score || 0,
        correctIndex: best?.correctIndex,
        studentIndex: sIndex
      };
    });

    // Sort by score descending
    scoredRows.sort((a, b) => b.score - a.score);

    // Only best match per group counts
    if (scoredRows.length > 0) {
      const { score: bestScore, correctIndex } = scoredRows[0];
      if (!usedCorrectIndexes.has(correctIndex)) {
        score += bestScore;
        usedCorrectIndexes.add(correctIndex);
      }
    }

    totalPossibleCorrect += correctRows.length * 4;
  });

  return { score, totalPossibleCorrect };
}


function scoreMatch(student, correct) {
  if (!correct) return 0;
  let score = 0;
  if (student.account === correct.account) score++;
  if (student.element === correct.element) score++;
  if (student.isDebitCredit === correct.isDebitCredit) score++;
  if (formatAmount(student.amount) === formatAmount(correct.amount)) score++;
  return score;
}


function markStudentAnswers(studentEffects, correctEffects) {
  const result = [];
  const types = [
    "Increase in asset", "Increase in liability", "Increase in equity",
    "Increase in income", "Increase in expense", "Decrease in asset",
    "Decrease in liability", "Decrease in equity", "Decrease in income",
    "Decrease in expense"
  ];

  types.forEach(type => {
    const studentGroup = studentEffects.filter(e => e.element === type);
    const correctGroup = correctEffects.filter(e => e.element === type);
    const usedCorrectIndexes = new Set();

    console.log(`üîç Type "${type}" ‚Äî ${studentGroup.length} student entries, ${correctGroup.length} correct entries`);

    const scored = studentGroup.map((student, sIndex) => {
      const scores = correctGroup.map((correct, cIndex) => {
        if (!correct) return { score: 0, correctIndex: cIndex, correct: null };
        return {
          score: scoreMatch(student, correct),
          correctIndex: cIndex,
          correct
        };
      });

      const best = scores.sort((a, b) => b.score - a.score)[0];
      return {
        student,
        score: best?.score || 0,
        correctIndex: best?.correctIndex,
        correct: best?.correct,
        studentIndex: sIndex
      };
    });

    scored.sort((a, b) => b.score - a.score);

    scored.forEach((entry, i) => {
      const { student, correct, score, correctIndex } = entry;
      const alreadyUsed = usedCorrectIndexes.has(correctIndex);

      let mark = {};
      const effectIndex = result.length;

      if (!correct) {
        console.warn(`‚ö†Ô∏è [${effectIndex}] No match for "${student.account}"`);
        mark = {
          account: `${student.account}‚ùå (No match)`,
          amount: `${student.amount}‚ùå (No match)`,
          element: `${student.element}‚ùå (No match)`,
          isDebitCredit: `${student.isDebitCredit}‚ùå (No match)`
        };
      } else if (i === 0 && !alreadyUsed) {
        usedCorrectIndexes.add(correctIndex);
        mark = {
          account: `${student.account}${student.account === correct.account ? '‚úÖ' : '‚ùå'}`,
          amount: `${student.amount}${formatAmount(student.amount) === formatAmount(correct.amount) ? '‚úÖ' : '‚ùå'}`,
          element: `${student.element}${student.element === correct.element ? '‚úÖ' : '‚ùå'}`,
          isDebitCredit: `${student.isDebitCredit}‚úÖ`
        };
        console.log(`‚úÖ [${effectIndex}] Marked "${student.account}" as correct`);
      } else {
        console.log(`üîÅ [${effectIndex}] Duplicate match for "${student.account}" ‚Äî skipping`);
        mark = {
          account: `${student.account}‚ùå (Duplicate ${type})`,
          amount: `${student.amount}‚ùå (Duplicate ${type})`,
          element: `${student.element}‚ùå (Duplicate ${type})`,
          isDebitCredit: `${student.isDebitCredit}‚ùå (Duplicate ${type})`
        };
      }

      result.push({ effect: mark });
    });
  });

  // ‚úÖ Count all effect fields with at least one ‚úÖ mark
  const totalChecks = result.reduce((sum, entry, index) => {
    const values = Object.values(entry.effect);
    const checks = values.filter(v => v.includes("‚úÖ")).length;
    console.log(`üìä Effect ${index}: ${checks} ‚úÖ`);
    return sum + checks;
  }, 0);

  console.log(`üì¶ Total effects generated: ${result.length}`);
  console.log(`‚úÖ Total checkmarks across all effects: ${totalChecks}`);

  // üîç Detect duplicate effects by stringifying
  const effectStrings = result.map(r => JSON.stringify(r.effect));
  const duplicateMap = new Map();

  effectStrings.forEach((str, i) => {
    if (duplicateMap.has(str)) {
      console.warn(`‚ö†Ô∏è Effect ${i} is a duplicate of effect ${duplicateMap.get(str)}`);
    } else {
      duplicateMap.set(str, i);
    }
  });

  return result;
}

function calculateTotalScore(questions) {
  let totalScore = 0;
  let totalPossibleCorrect = 0;

  questions.forEach(question => {
    const { score, totalPossibleCorrect: possible } = calculateScoreForQuestion(question);
    totalScore += score;
    totalPossibleCorrect += possible;
  });

  return { totalScore, totalPossibleCorrect };
}

    function getLetterGrade(score, totalItems) {
      const percentage = (score / totalItems) * 100;
      if (percentage >= 95) return "A";
      if (percentage >= 85) return "P";
      if (percentage >= 75) return "D";
      return "IR";
    }

   function setupAutoSubmit(endTimeMillis) {
      const now = Date.now();
      const delay = endTimeMillis - now;
      if (delay > 0) {
        setTimeout(() => {
          if (!submitBtn.disabled) {
            submitBtn.click();
          }
        }, delay);
      }
    }

    function updateSubmitButtonState() {
      //const allAnswered = shuffledQuestions.every(q => q.studentAnswer);
      //submitBtn.disabled = !allAnswered;
  const totalItems = getTotalExpectedInputs(shuffledQuestions);
  const rawInputCount = countRawStudentInputs(studentAnswersLog);

  console.log(`üßÆ Raw Inputs Logged: ${rawInputCount} / ${totalItems}`);
  submitBtn.disabled = rawInputCount < totalItems;
    }

function getTotalExpectedInputs(shuffledQuestions) {
let totalItems = 0;

shuffledQuestions.forEach((question, index) => {
  const questionKey = `Q${String(index + 1).padStart(2, "0")}`;
  const correctAnswer = Array.isArray(question.answer)
    ? { effects: question.answer }
    : question.answer;

  if (!correctAnswer) {
    console.warn(`‚ö†Ô∏è ${questionKey} missing correctAnswer`);
    return;
  }

  // ‚úÖ Compute max possible points
  let maxPoints = 0;
  if (correctAnswer.type) maxPoints += 1;
  if (Array.isArray(correctAnswer.effects)) {
    maxPoints += correctAnswer.effects.length * 4;
  }
  totalItems += maxPoints;
  });
  return totalItems;
}

function countRawStudentInputs(studentAnswersLog) {
  let count = 0;

  Object.values(studentAnswersLog).forEach(entry => {
    const rawInput = entry?.["04_studentAnswers"]?.["c_rawStudentInput"];
    if (!rawInput) return;

    if (rawInput.type) count += 1;

    if (Array.isArray(rawInput.effects)) {
      rawInput.effects.forEach(effect => {
        count += Object.keys(effect).length;
      });
    }
  });

  return count;
}

function renderAllJournalEntries(log) {
  const panel = document.getElementById("journalPanel"); // Make sure this exists in your HTML
  const headerText = "üìò Student Journal Entries";

  panel.innerHTML = `
    <h3>${headerText}</h3>
    <div style="overflow-x: auto;">
      <table style="width: max-content; border-collapse: collapse;">
        <thead>
          <tr>
            <th style="width: 7ch; font-family: monospace; font-size: 14px;">Date</th>
            <th style="width: 40ch; font-family: monospace; font-size: 14px;">Account Titles and Explanation</th>
            <th style="width: 3ch; font-family: monospace; font-size: 14px;">PR</th>
            <th style="width: 10ch; font-family: monospace; font-size: 14px; text-align: center;">Debit</th>
            <th style="width: 10ch; font-family: monospace; font-size: 14px; text-align: center;">Credit</th>
          </tr>
        </thead>
      </table>
      <div style="max-height: 300px; overflow-y: auto;">
        <table id="journalTable" style="width: max-content; border-collapse: collapse;">
          <tbody id="journalBody"></tbody>
        </table>
      </div>
    </div>
  `;

  const tbody = panel.querySelector("#journalBody");

  // üîÅ Loop through each question's journal entries
  Object.entries(log).forEach(([questionKey, entry]) => {
    const question = entry.question;
    const journalEntries = entry.journalEntries || [];

    // üìù Optional: Add a separator row with the question and date
    const separatorRow = document.createElement("tr");
    separatorRow.innerHTML = `
      <td colspan="5" style="font-weight: bold; font-family: monospace; padding-top: 10px;">
        (${question.Date}) - ${question.question}
      </td>
    `;
    tbody.appendChild(separatorRow);

    // üßæ Add each journal row
    journalEntries.forEach(({ date, account, pr, debit, credit }) => {
      const row = document.createElement("tr");
      row.innerHTML = `
        <td style="font-family: monospace;">${date}</td>
        <td style="font-family: monospace;">${account}</td>
        <td style="font-family: monospace; text-align: center;">${pr}</td>
        <td style="font-family: monospace; text-align: right;">${debit}</td>
        <td style="font-family: monospace; text-align: right;">${credit}</td>
      `;
      tbody.appendChild(row);
    });
  });
}

async function submitStudentAnswer() {
  const selectedQuestion = shuffledQuestions[selectedQuestionIndex];
  const { Idnumber, CN, LastName, firstName } = currentStudent;

  const studentId = Idnumber;
  const studentCN = CN;
  const studentLastName = LastName;
  const studentFirstName = firstName;

  const collectionId = `results_${title}_${attendanceId}`;
  const documentId = `${studentCN}-${studentId}-${studentLastName}-${studentFirstName}`;

  const documentData = {
    "01_schoolyear": "SY 2025-2026",
    "02_subject": "FABM 1",
    "03_term": "1st Semester",
    "04_title": studentAnswersLog.title || "mtformative06",
    "05_section": attendanceId,
    "06_type": studentAnswersLog.type,
    "07_topics": studentAnswersLog.topics,
    "08_numOfQuestions": studentAnswersLog.num,
    "09_instructions": studentAnswersLog.instructions,
    "10_rubric": studentAnswersLog.rubricHTML,
    "11_duration": studentAnswersLog.duration,
    "12_endTime": new Date(studentAnswersLog.endTime).toLocaleString("en-PH", {
      weekday: "short", year: "numeric", month: "short", day: "numeric",
      hour: "2-digit", minute: "2-digit", hour12: true
    }),
    "13_timesubmittedAt": new Date().toISOString(),
    "14_questionsAndAnswers": studentAnswersLog
  };

  const resultRef = doc(db, collectionId, documentId);

  try {
    await setDoc(resultRef, documentData, { merge: true });
    console.log("‚úÖ Submitted to Firestore:", documentData);
    submitBtn.disabled = true;

    localStorage.setItem("studentAnswersLog", JSON.stringify(documentData));
    console.log("üì¶ Saved to localStorage");

    renderAllJournalEntries(studentAnswersLog); // ‚úÖ Render journal entries
const summaryPanel = document.getElementById("submissionSummary");
if (summaryPanel) {
  summaryPanel.innerHTML = `
    <div style="padding: 1rem; background-color: #f0f4ff; border: 1px solid #c3dafe; border-radius: 6px; font-family: sans-serif;">
      <h4 style="margin-top: 0;">üìã Submission Summary</h4>
      <p><strong>Student:</strong> ${studentFirstName} ${studentLastName} (${studentCN})</p>
      <p><strong>Section:</strong> ${attendanceId}</p>
      <p><strong>Activity Title:</strong> ${studentAnswersLog.title}</p>
      <p><strong>Type:</strong> ${studentAnswersLog.type}</p>
      <p><strong>Topics:</strong> ${Array.isArray(studentAnswersLog.topics) ? studentAnswersLog.topics.join(", ") : studentAnswersLog.topics}</p>
      <p><strong>Instructions:</strong> ${studentAnswersLog.instructions}</p>
      <p><strong>Submitted At:</strong> ${new Date().toLocaleString("en-PH", {
        weekday: "short", year: "numeric", month: "short", day: "numeric",
        hour: "2-digit", minute: "2-digit", hour12: true
      })}</p>
    </div>
  `;
} else {
  console.warn("‚ö†Ô∏è submissionSummary panel not found in DOM.");
}
    
  } catch (err) {
    console.error("‚ùå Submission error:", err);
  }
}
});

</script>
</body>
</html>
